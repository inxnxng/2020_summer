# 포인터와 연결 리스트

20200728

## 포인터

모든 메모리는 주소를 갖는다. **포인터**는 이러한 메모리의 어떤 주소를 저장하기 위해서 사용되는 변수를 말한다. 보통 그 주소에는 **다른 변수**가 저장되어 있다.
컴퓨터의 메모리는 바이트 단위로 구성되어 있고 각 바이트 마다 순차적으로 주소가 매겨져 있다.

```cpp
char ch a= 'a';     // 1. 문자형 변수 ch 선언 및 초기화
char* p;            // 2. 포인터 변수 p 선언
p = &ch;            // 3. 포인터 변수 값 저장
*p = 'b';           // 4. p가 가리키는 곳의 내용을 변경
char** pp;          // 5. 이중 포인터 변수 pp 선언
pp = &p;            // 6. p의 주소를 pp에 복사
```

1. char형 변수 ch를 선언하고 초기화. 메모리에서 char형을 저장할 수 있는 크기의 공간을 찾아 ch라는 이름을 부여하고 그 공간에 'a'를 복사. 모든 **변수**(**객체**)는 반드시 메모리를 차지하며 주소를 갖지만 **상수**는 공간을 차지하지도 않고 따라서 주소도 없다. 'a'는 상수인 것.

2. `char* p`; 문장은 새로운 **포인터 변수** p를 선언 포인터 또한 변수이기 때문에 메모리를 차지하고 주소를 갖는다. 자료형이 char*이므로 p는 char변수가 저장되어 있는 공간의 주소를 저장하기 위해 사용 될 것(64비트 운영체제가 되고 나서 포인터 변수의 크기는 8bytes)

3. `p = &ch;` 문장은 ch의 주소를 포인터 변수 p에 저장하는 문장. 변수의 주소는 **& 연산자**를 변수에 적용하여 얻는다. 즉 &ch 연산 결과는 주소(변수 ch가 있는 메모리 의 주소)이며 자료형은 _ch가 char형이므로 &ch는 char* 가 된다._ 결국 포인터 변수 p에 변수 ch의 주소가 저장되어 있으며 이것을 보통 **"p가 변수 ch를 가리킨다"**라고 말한다.

4. *p가 **p가 가리키는 곳의 객체**를 의미하는데, **변수 ch**를 말한다.  결국 *p와 변수 ch는 전적으로 동일하다. 따라서 *p의 값을 변경하면 변수 ch의 값도 바뀐다. 포인터 변수가 가리키는 메모리의 내용을 추출하거나 변경하려면 **\* 연산자**를 사용한다. `*p = 'b';` --> `ch = 'b';`와 동일. p가 가리키는 곳의 내용을 'b'로 교체한 것

5. `char** pp;`는 이중 포인터 변수 pp를 선언한 것. pp도 변수이므로 메모리 공간을 차지하고 물론 주소도 갖는다. pp의 크기는 p와 동일하다. 모든 포인터 변수의 크기는 동일하다 --> 하나의 컴퓨터에서 주소체계는 동일하며 주소가 몇번지이든 주소를 저장하는데 필요한 공간은 동일하기 때문.

6. `pp = &p;` 문장은 변수 p의 주소를 이중 포인터 변수 pp에 복사하는 것. &p는 변수 p의 주소를 추출한다. &p의 자료형은 char*\*. p의 자료형이 char\*이므로 &p는 char*형 변수가 들어있는 메모리의 주소이므로 char**가 된다. 결국 &p의 자료형은 변수 pp의 자료형과 일치하며 &p의 연산 결과를 pp에 복사할 수 있다. 

| 표현  |   자료형   | 동일한 표현 |
| :---: | :--------: | :---------: |
|  'a'  | char(상수) |             |
|  ch   |    char    |   *p,**p    |
|   p   |   char*    |   *pp,&ch   |
|  pp   |   char**   |     &p      |

* a - - - - ch - - - - p - - - - pp

### 포인터 변수의 선언

`char* p,q,r;` 는 p가 char\*의 변수, q과 r은 char 변수
`char *p, *q, *r;`로는 p, q, r 모두 char*형 변수

나머지는 다 알고 익숙하나 몇개만 서술
* `int** pp;`           : 포인터 변수의 주소를 저장하기 위한 포인터
* `void (*f)(int);`     : int를 매개변수로 갖고 반환이 없는 함수의 주소를 저장하기 위한 포인터
* `void* p;`            : 아무것도 가리키지 않는 포인터. void 포인터는 필요할 때 마다 다음과 같은 포인터로 바꾸어 사용한다. --> `pi = (int*)p;`

### 함수와 포인터

swap함수에 변수 차이
[참고](https://stackoverflow.com/questions/35718222/swapint-a-int-b-and-swapint-a-int-b-what-is-difference)

레퍼런스 설명 깔끔
[참고](https://blog.naver.com/lyw94k/220848192898)

### 배열과 포인터

배열의 이름이 배열의 첫 번째 항목을 가리키는 포인터처럼 사용되는 것만 생각하고 있자.

### 객체와 포인터

s라는 클래스 객체와 포인터 변수 ps를 선언하는 코드이다.
`s.i == ps->i == (*ps).i`

* `double pointDistance1(Point2D a, Point2D b);`
    * 두개의 Point2D 변수에 대한 복사가 일어나고 복사 생성자가 호출된다.
* `double pointDistance1(Point2D* pa, Point2D* pb);`
    * 클래스의 크기와는 상관없이 매개변수 전달을 위해 pa와 pb의 주소만을 복사한다. 주소값의 복사는 객체의 복사에 비해 훨씬 용이하다.

reference를 사용하는 것도 좋은 방법이다. 복사가 일어나는 **값에 의한 호출(call-by-value)**이 아니라 인수에 대한 별명을 사용하여 단순히 참조하는 것으로 **참조에 의한 호출(call-by-reference)**이라고 부른다. 이 경우 매개변수 전달을 위해 어떤 복사도 일어나지 않는다.

### 자체 참조 클래스(self-referentail class)

특별한 클래스로서 멤버 변수들 중에서 동일한 클래스의 객체를 가리키는 포인터가 한개 이상 존재하는 클래스를 말한다.
미리 일정한 크기를 할당하는 배열과 달리 **일반적으로 항목의 개수를 미리 예측할 수 없는 경우**에 자체 참조 클래스를 정의하고 동적으로 객체를 생성하여 이들을 포인터로 연결하는 구조에서 흔히 사용된다.

```cpp
void foo(int a) {
	cout << "foo : " << a << endl;
}

void(*f)(int);
f = foo;
```

f라는 이름의 포인터는 int형 변수를 받고 void를 return하는 함수를 가리킨다 
`foo(10) == f(10) == (*f)(10)` 다 같은 표현

### 포인터에 대한 연산

* `p`           : 포인터
* `*p`          : 포인터가 가리키는 값
* `*p++`        : 포인터가 가리키는 값을 가져온 다음, 포인터를 한 칸 증가
* `*p--`        : 포인터가 가리키는 값을 가져온 다음, 포인터를 한 칸 감소
* `(*p)++`      : 포인터가 가리키는 값을 증가시킨다.

### 포인터 사용시 주의점

1. 포인터가 어떤 값을 가리키고 있지 않다면 `NULL`로 설정하라.
2. 초기화가 안된 포인터 변수가 가리키는 곳에 자료를 저장하면 안된다.
3. 포인터 타입 간의 변환 시에는 명시적인 형변환을 사용한다.

## 동적 메모리 할당

* 동적 메모리 할당(static memory allocation)
    * 필요한 메모리의 크기가 프로그램이 컴파일 될 때 결정되고 **프로그램의 실행 중에 크기를 변경할 수 없다**
    * 생성과 제거가 자동으로 이루어진다. 변수를 선언만 하면 자동으로 메모리가 할당되고 해당 프로그램 블록이 끝나면 자동으로 제거된다

* 정적 메모리 할당(dynamic memory allocation)
    * 동적 메모리 할당은 실행 도중에 메모리를 할당받는 것이다
    * 프로그램 실행 중에 필요한 메모리의 크기를 결정하고 시스템으로부터 할당받아서 사용하고 해제한다. 따라서 메모리를 효율적으로 사용할 수 있다
    * 하지만 개발자가 메모리의 생성과 해제를 직접 관리해야하는 번거로움이 있다

```cpp
int main(){
    int x;                      //정적으로 int객체 할당
    int * py = new int;         //동적으로 int객체 할당
    x = 10;                     
    *py = 20;
    delete py;                  //동적으로 int객체 제거

    int arrA[20];               //정적으로 배열 할당
    int* arrB = new int [20];   //동적으로 배열 할당
    arrA[3] = 10;               //정적 배열 사용
    arrB[3] = 20;               //동적 배열 사용
    delete [] arrB;             //동적으로 배열 제거
}                               //정적 객제(x, arrA) 자동 해제
```

`int* arrB = new int [x]`를 잊지 말자 `int x;` 후 x값을 수정해도 문제가 없다

### 동적 메모리 할당과 해제를 위한 연산자

* new 연산자
    * `data_type *pData = new data_type;`
    * `data_type *array = new data_type [size];`
    * 만약 메모리의 확보가 불가능하다면 new는 `NULL`을 반환한다
* delete 연산자
    * `delete pData;`
    * `delete[] array;` : 여러 개의 객체가 한번에 할당된 경우 `[]`를 사용하여 정확한 크기의 메모리 해제가 이루어지도록 해야한다

### 2차원 배열의 동적 할당

1. int* 형 데이터를 저장할 공간 rows개를 동적으로 할당한다. 이 공간의 주소는 이중 포인터 변수 mat에 저장한다. (int **mat;)
2. 행렬의 i번째 행의 요소를 저장하기 위한 int형 배ㅕㄹ을 동적으로 할당하여 그 주소를 mat\[i]에 저장한다. 이 때 요소의 개수는 cols개이다.
3. 모든 행에 대해 2번 과정을 반복한다.

* mat : int** 형
    * mat\[i] : int* 형
        * mat\[i]\[j] : int 형

---

## 연결 리스트

연결된 표현(linked representation)을 이용해서 동적으로 크기가 변할 수 있는 방법을 찾는다.</br>
스택, 큐, 리스트, 덱, 트리, 그래프에서 사용된다

* 데이터를 한군데 모아두는 것을 포기한다
* 데이터들은 메인 메모리상의 어디에나 흩어져 존재
* 순서를 유지하기 위해 각각의 데이터는 다음 데이터는 다음 데이터를 가리키는 줄을 가진다
* 첫 데이터에서부터 순서대로 줄을 따라가면 모든 데이터를 방문할 수 있다

__연결 리스트(linked list) by POINTER__

### 연결 리스트의 구조

* 노드 : 데이터 필드와 링크 필드로 구성되어 있음
    * 데이터 필드 : 우리가 저장하고 싶은 자료. 정수 또는 클래스 객체와 같이 복잡한 자료형이 될 수도 있음
    * 링크 필드 : 다른 노드의 주소를 저장하는 포인터 변수가 있음

* 헤드 포인터
* 마지막 노드 --> 링크 필드를 NULL로 설정한다.
  
### 구현해야할 연결 스택의 동작

top --> C --> B --> A --> NULL</br>

#### 삽입

여기서 D를 추가하려고 할 때, 여기서 p는 D를 가리키고 있는 노드 </br>

1. 노드 D의 링크 필드가 노드 C를 가리키도록 한다 : p -> link = top;
2. 헤더 포인터 top이 노드 D를 가리키도록 한다 : top = p;

#### 삭제

노드 C를 삭제하려고 할 때,

임시 포인터 변수 p 를 생성하여

1. 포인터 변수 p가 C를 가리키도록 한다 : p = top;
2. 헤더 포인터 top이 B를 가리키도록 한다 : top = p->link; 즉 B를 향하도록 하는거지. p가 향하던 link의 다음 링크는 B니까
3. 마지막으로 포인터 P를 반환한다 : return p;

노드 해제 후에는 잊지 말고 `delete node;`해줘야 한다.

### 연결리스트로 구현한 큐의 구조

```python

1. 공백 상태일 때

front, rear 
    NULL

     +

p
A ----->NULL

     =

front,rear
  A ------->NULL

2. 공백 상태가 아닐 때

front     rear
  A----B----C---->NULL

     +

p
D---->NULL

     =

front           rear
  A----B----C---->D---->NULL

```

#### 삽입

1. rear가 가리키는 노드 C가 노드 p를 가리키도록 한다 : rear -> link = p ;
2. rear가 이제 노드 p를 가리키도록 한다 : rear -> p;

`front = front -> getLink();` front 앞에 있던 / 다음의 node와 연결
`p = p->getLink();` 와 같은 맥락

#### 삭제

연결리스트 맨 앞에서 노드를 꺼내오면 된다. 우선 공백상태인지 검사하고 공백 상태가 아니라면 삭제를 진행한다.

1. front가 가리키는 노드 A를 p가 가리키도록 한다 : p = front;
2. front가 다음 노드 B를 가리키도록 한다 : front = p->link;

## 마지막..

결국 중요한 표현만 가져가자면

* 스택
    * `void setLink(Node* p){ link = p ;}`
    * `p->link = top` (p가 향하는 다음 link가 top이 되어라) --> `p ->setLink(top);`
    * `void getLink() { return link; }`
    * `top = p->link;` (p가 향하는 다음 링크를 top으로 선언해라) --> `top = top->getLink()`

* 큐
    * `rear -> link = p;` (새로운 p를 rear가 향하는 다음 링크로 선언해라) --> `rear -> setLink(p);`
    * `front = p -> link` (p는 front를 복제한 놈임. p가 향하는 다음 노드는 두번째 노드고 이걸 front로 붙여줘라) --> `front = front -> getLink()` 

## 포인터와 레퍼런스

보면 볼 수록 새로워 당신들..

1. 참조 대상 할당 및 접근

```cpp
int a = 10;
int *p = &a;        // 포인터는 주소값을 할당
int *r = a;         // 레퍼런스는 대상을 직접 할당
```
포인터는 *, -> 등의 포인터 연산자들을 통해 접근해야 하지만 레퍼런스는 _마치_ 지역변수처럼 접근할 수 있다.

> Use references when you can, and pointers when you have to.

[다시 한번 더 포인터 체크](##-포인터)
