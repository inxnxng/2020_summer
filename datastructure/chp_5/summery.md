# 포인터와 연결 리스트

20200728

## 포인터

모든 메모리는 주소를 갖는다. **포인터**는 이러한 메모리의 어떤 주소를 저장하기 위해서 사용되는 변수를 말한다. 보통 그 주소에는 **다른 변수**가 저장되어 있다.
컴퓨터의 메모리는 바이트 단위로 구성되어 있고 각 바이트 마다 순차적으로 주소가 매겨져 있다.

```cpp
char ch a= 'a';     // 1. 문자형 변수 ch 선언 및 초기화
char* p;            // 2. 포인터 변수 p 선언
p = &ch;            // 3. 포인터 변수 값 저장
*p = 'b';           // 4. p가 가리키는 곳의 내용을 변경
char** pp;          // 5. 이중 포인터 변수 pp 선언
pp = &p;            // 6. p의 주소를 pp에 복사
```

1. char형 변수 ch를 선언하고 초기화. 메모리에서 char형을 저장할 수 있는 크기의 공간을 찾아 ch라는 이름을 부여하고 그 공간에 'a'를 복사. 모든 **변수**(**객체**)는 반드시 메모리를 차지하며 주소를 갖지만 **상수**는 공간을 차지하지도 않고 따라서 주소도 없다. 'a'는 상수인 것.

2. `char* p`; 문장은 새로운 **포인터 변수** p를 선언 포인터 또한 변수이기 때문에 메모리를 차지하고 주소를 갖는다. 자료형이 char*이므로 p는 char변수가 저장되어 있는 공간의 주소를 저장하기 위해 사용 될 것(64비트 운영체제가 되고 나서 포인터 변수의 크기는 8bytes)

3. `p = &ch;` 문장은 ch의 주소를 포인터 변수 p에 저장하는 문장. 변수의 주소는 **& 연산자**를 변수에 적용하여 얻는다. 즉 &ch 연산 결과는 주소(변수 ch가 있는 메모리 의 주소)이며 자료형은 _ch가 char형이므로 &ch는 char* 가 된다._ 결국 포인터 변수 p에 변수 ch의 주소가 저장되어 있으며 이것을 보통 **"p가 변수 ch를 가리킨다"**라고 말한다.

4. *p가 **p가 가리키는 곳의 객체**를 의미하는데, **변수 ch**를 말한다.  결국 *p와 변수 ch는 전적으로 동일하다. 따라서 *p의 값을 변경하면 변수 ch의 값도 바뀐다. 포인터 변수가 가리키는 메모리의 내용을 추출하거나 변경하려면 **\* 연산자**를 사용한다. `*p = 'b';` --> `ch = 'b';`와 동일. p가 가리키는 곳의 내용을 'b'로 교체한 것

5. `char** pp;`는 이중 포인터 변수 pp를 선언한 것. pp도 변수이므로 메모리 공간을 차지하고 물론 주소도 갖는다. pp의 크기는 p와 동일하다. 모든 포인터 변수의 크기는 동일하다 --> 하나의 컴퓨터에서 주소체계는 동일하며 주소가 몇번지이든 주소를 저장하는데 필요한 공간은 동일하기 때문.

6. `pp = &p;` 문장은 변수 p의 수조슬 이중 포인터 변수 pp에 복사하는 것. &p는 변수 p의 주소를 추출한다. &p의 자료형은 char*\*. p의 자료형이 char*이므로 