# 큐 QUEUE

20200724

## 큐란?

**선입선출 (First-IN First-Out)** 뒤에서 새로운 데이터가 추가되고 앞에서 데이터가 하나씩 삭제되는 구조.
스택과 다른 점은 스택에서는 삽입과 삭제가 같은 쪽에서 일어나지만 큐는 다른 쪽에서 일어난다는 점

------------------------------
         전단(front)        후단(rear)
<-  @A@  <-  @B@  <-  &C&  <-  &D&  <-  @E@
\------------------------------ 
@@는 비어있고 &&는 차있는 것

### 큐의 추상 자료형

* 데이터 : 선입선출(FIFO)의 접근 방법을 유지하는 요소들의 모임
* 연산 :
    * enqueue(e) : 주어진 요소 e를 큐의 맨 뒤에 추가
    * dequeue() : 큐가 비어있지 않으면 맨 앞의 요소를 삭제하고 반환
    * isEmptu() : 큐가 비어 있으면 true 아니면 false
    * peek() : 큐가 비어있지 않으면 맨 앞 요소를 삭제하지 않고 반환
    * isFull() : 큐가 가득 차 있으면 true 아니면 false
    * size() : 큐의 모든 요소들의 개수를 반환
    * display() : 큐의 모든 요소를 출력

두개의 위치 변수가 필요하다.
1. rear : 삽입 관련
2. front : 삭제 관련


### 선형 큐

**시간 복잡도???**
계속 front와 rear은 증가하므로 항목 이동이 필요하다

### 원형 큐

원형 큐에서는 항상 칸 하나를 비워놔야 함. 포화 상태와 공백 상태를 구별하기 위함임.
`front == rear`이면 공백 상태

## 덱

**덱(deque : double-ended queue)** 는 큐의 전단과 후단에서 모두 삽입과 삭제가 가능한 큐. 하지만 중간에 삽입하거나 삭제는 허용하지 않는다.

### 덱의 추상 자료형

* 데이터 : 전단과 후단을 통한 접근을 허용하는 요소들의 모임
* 연산
    * addFront(e) : 주어진 요소 e를 덱의 맨 앞에 추가
    * deleteFront() : 덱이 비어있지 않다면 맨 앞의 요소를 삭제하고 반환
    * addRear(e)
    * deleteRear()
    * isEmpty()
    * getFront()
    * getRear()
    * isFull()
    * display() 

## 큐잉 이론

큐잉이론은 심화학습 때..

