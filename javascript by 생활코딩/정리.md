# 잉크 with JAVASCRIPT

## 객체

```javascript
var grades = {
    'list': {'egoing': 10, 'k8805': 6, 'sorialgi': 80},
    'show' : function(){
        for(var name in this.list){
            document.write(name+':'+this.list[name]+"<br />");
        }
    }
};
grades.show();

```

var grades 라는 이름의 객체를 만들겠다.
그 안에는 'list'라는 아이가 있는데 걔는 배열이다.
'show'라는 아이가 있는데 얘는 function이다.
`: function(){}` 을 통해 function으로만 선언하지 않고 함수의 이름을 붙여준 것과 같다. 여기서는 'show'가 function의 이름.


## 모듈

* 호스트 환경이란?
자바스크립트가 구동되는 환경을 의미한다. 예를 들어 node.js는 서버 측에서 실행되는 자바스크립트다. 이 언어는 자바스크립트의 문법을 따르지만 이 언어가 구동되는 환경은 브라우저가 아니라 **서버측 환경**이다.

```javascript
<!DOCTYPE html>
<html>
<head>
    <meta charset = 'utf-8'/>
    <script src = "greeting.js"></script>
</head>
<body>
    <script>
        alert(welcome());
    </script>
</body>
</html>
```

`<script src = "greeting.js"></script>`는 src속성을 가져와 다운하여 소스 안에 있는 함수를 쓸 수 있음. 즉 main.html안에 이 함수가 정의되어 있지 않음에도 실행할 수 있음.

### nodejs 맛보기

```javascript
var PI = Math.PI;

exports.area = function(r){
    return PI  *r *r;
};

export.circumference = function(r ){
    return 2*PI*r;
}
```

```javascript
var circle  = require('./node.circle.js'); //import 느낌인거지
console.log( 'The area of a circle of radius 4 is '+ circle.area(4));
```

### 라이브러리

라이브러리는 모듈과 비슷한 개념. 모듈이 프로그램을 구성하는 작은 부품으로서의 로직이라면 라이브러리는 자주 사용되는 로직을 재사용하기 편리하도록 잘 정리한 일련의 코드들의 집합.

#### jQuery VS Javascript

순수 자바스크립트에서 이벤트 핸들러 사용시 번거로움을 제이쿼리로 줄일 수 있음

### API

application programming interface. 프로그램이 동작하는 환경을 제어하기 위해서 환경에서 제공되는 조작 장치

#### UI? API?

[참고](https://estelar.tistory.com/66)

공통점 : interface 제공
차이점 : USER / APPLICATION PROGRAMMING

* UI : 컴퓨터 시스템과 컴퓨터를 사용하는 사람 사이의 접점에 위치하면서 입력장치, 출력장치들에 해당되는 접점/중계자에 해당함. 사용자를 대면하는 접점이 되는 지점을 포괄적으로 이야기하는 것.

## 정규표현식 

[참고](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/%EC%A0%95%EA%B7%9C%EC%8B%9D)

compile execution 으로 이루어진다.

문자열에 나타나는 특정 문자 조합과 대응시키기 위해 사용되는 패턴. 자바스크립트에서는 정규 표현식 또한 객체다. 

* compile : 검출하고자 하는 패턴을 만드는 일. 우선 정규표현식 객체를 만들어야 함.

    * 정규표현식 리터럴 : `var pattern = /a/`
        * 정규식 리터럴(슬래쉬 / 로 감싸는 패턴)
        * 정규식이 상수라면 성능 향상
        * 스크립트가 불러와질 때 컴파일 된다 
  
    * 정규표현식 객체 생성자 : `var pattern = new RegExp('a');`
        * RegExp 객체의 생성자 함수를 호출하는 방법 
        * 정규식이 실행 시점에 컴파일 된다
        * 정규식의 패턴이 변경될 수 있는 경우 혹은 사용자 입력과 같이 다른 출처로부터 패턴을 가져와야하는 경우 생성자 함수를 사용하라

이거 이산구조 마지막 단원쯤에 돌고도는 맵 그거임
이거는 url 검색할 때 검색 단어 찾기에 쓰일 듯

## 함수지향

자바 스크립트에서 함수는 객체를 이해하는 데 가장 중요한 기초를 이룬다. 
내 문제 : 오픈소스 수업 프로젝트에 전역변수를 남발함

### 유효범위

```javascript
var scope = 'global';
function fscope(){
    alert(vscope);
}
fscope();
```

결과는 global이다.

```javascript
var vscope = 'global';
function fscope(){
    var vscope = 'local';
    alert('함수안 ' + vscope);
}
fscope();
alert('함수 밖 '+vscope);
```

내가 파악해야하는 것은 변수를 선언할 때는 꼭 var을 붙이는 것, 전역변수를 사용해야한다면 그것을 사용하는 이유가 명확해야하고, 함수를 저렇게 선언하는 구나 이 정도?

### 값으로서 함수와 콜백


객체의 속성 값으로 담겨진 함수를 method라고 부른다

```javascript

a = {
    b: function(){}
};
```

함수는 함수의 리턴 값으로도 사용할 수 있다

```javascript
function cal(mode) {
    var funcs = {
        'plus': function(left,right){return left+right;},
        'minus': function(l,r){return l-r;}
    }
    return funcs[mode];
}

alert(cal('plus')(2,1));
alert(cal('minus')(2,1));  
```

배열 값으로도 사용할 수 있다
왜 아래 값이 60.5이 나오는지 think
[참고](https://youtu.be/1pqJphcounU)

```javascript
var process = [
    function(input){return input +10;},
    function(i){return i*i;},
    function(i){return i/2;}
];

var input = 1;

for(var i = 0 ; i < process.length; i++){
    input = process[i]\(input\);
}
alert(input);
```

[콜백 - 비동기 처리](https://youtu.be/NDFjwybbong)

Ajax (Asynchronous : 비동기 javascript and XML)

값으로서의 함수

$ : jQuery에서 객체로 받는 부분

get : 요청한다!!!! 오픈소스 수업

1번째 인자 : 주소

2번째 인자 : 주소에서 받아온 값을 result에 넣는다

3번째 인자 : 파일 형식

```javascript
$.get('./datasource.json.js', function(result){
        console.log(result);
    }, 'json');
```

### 클로져

**let**과 **const**를 이용하자~ :)

내부함수는 외부함수의 지역변수에 접근할 수 있는데 외부함수의 실행이 끝나서 외부함수가 소멸된 이후에도 내부함수가 외부함수의 변수에 접근할 수 있다.

```javascript
function outter(){
    var title = 'coding everybody';  
    return function(){        
        alert(title);
    }
}
inner = outter();
inner();
```

1. 함수 outter의 호출 -> 결과는 변수 inner에 담김
2. inner의 호출 하지만 outter 함수는 실행이 끝났기 때문에 이 함수의 지역변수는 소멸되는 것이 자연스럽다. 하지만 inner 실행시 coding everybody가 출력된다
3. 외부함수의 지역변수 title이 소멸되지 않았다는 것

**클로저란 내부함수가 외부함수의 지역변수에 접근할 수 있고, 외부함수는 외부함수의 지역변수를 사용하는 내부함수가 소멸될 때까지 소멸되지 않는다.

```javascript
function factory_movie(title){
    return {
        get_title : function (){
            return title;
        },
        set_title : function(_title){
            title = _title
        }
    }
}
ghost = factory_movie('Ghost in the shell');
matrix = factory_movie('Matrix');
 
alert(ghost.get_title());
alert(matrix.get_title());
 
ghost.set_title('공각기동대');
 
alert(ghost.get_title());
alert(matrix.get_title());
```

```javascript
var arr = []
for(var i = 0; i < 5; i++){
    arr[i] = function(id) {
        return function(){
            return id;
        }
    }(i);
}
for(var index in arr) {
    console.log(arr[index]());
}
```

밑 for문에 arr\[index]() 를 하면 외부함수만 넣을 때와 달리 첫 for문의 i에 접근할 수 있다.

### arguments

```javascript
function sum() {
    var i, _sum = 0; 
    for(i = 0 ; i<arguments.length; i++){
        document.write(i + ' : '+arguments[i]='\n');
        _sum+= arguments[i];
    }
    return _sum;
}
document.write('result :'+sum(1,2,3,4));
```

sum은 인자로 전달된 값을 모두 더해서 리턴하는 함수인데 첫 행에서의 함수는 인자에 대한 정의가 없다. 하지만 마지막 라인에서는 4개의 인자를 sum함수에게 전달하고 있다.
-->arguments라는 특수 배열이 있기 때문!!!!!<--
사실 arguments는 사실 배열이 아님. 객체의 인스턴스임.

### 매개변수

arguments.length는 **전달된 실제 인자의 수**
함수.length는 **함수에 정의된 인자의 수**

[참고](https://opentutorials.org/course/743/6548)

```javascript
function zero(){
    console.log(
        'zero.length', zero.length,
        'arguments', arguments.length
    );
}
function one(arg1){
    console.log(
        'one.length', one.length,
        'arguments', arguments.length
    );
}
function two(arg1, arg2){
    console.log(
        'two.length', two.length,
        'arguments', arguments.length
    );
}
zero(); // zero.length 0 arguments 0 
one('val1', 'val2');  // one.length 1 arguments 2 
two('val1');  // two.length 2 arguments 1
```

### 함수 호출

함수는 객체이다.

```javascript
function sum(arg1, arg2){
    return arg1+arg2;
}
alert(sum.apply(null, [1,2]))
```

sum은 Function 객체의 인스턴스다. 따라서 객체 Function의 메소드 apply를 호출할 수 있다. apply 메소드는 2개의 인자를 갖는다.
* 첫번째 인자 : 함수가 실행될 맥락.
* 두번째 인자 : 배열. 배열에 담겨있는 원소가 함수의 인자로 순차적으로 대입된다.

만약 apply의 첫번째 인자로 null을 전달하면 apply가 실행된 함수 인스턴스는 전역객체(브라우저에서는 window)를 맥락으로 실행되게 된다.